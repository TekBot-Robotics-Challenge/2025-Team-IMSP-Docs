# S0/S1, quâ€™est ce que câ€™est?

Le capteur TCS230 ne donne **pas directement une couleur** ou un nombre.

Il **sort un signal carrÃ©** (comme un train dâ€™impulsions) sur la broche `OUT`.

La **frÃ©quence** de ce signal est **inversement proportionnelle Ã  lâ€™intensitÃ© lumineuse** dÃ©tectÃ©e.

Mais cette frÃ©quence peut Ãªtre **trÃ¨s Ã©levÃ©e** (des centaines de kHz), donc difficile Ã  lire pour un Arduino, surtout si tu veux faire des calculs derriÃ¨re.

ğŸ‘‰ Câ€™est pour Ã§a quâ€™on utilise **S0 et S1** :

Ils servent Ã  **diviser la frÃ©quence du signal de sortie**, pour **rendre le signal plus facile Ã  lire**.

---

**ğŸ§  Tableau de configuration S0 / S1**

| S0 | S1 | FrÃ©quence de sortie |
| --- | --- | --- |
| L | L | 0% (sortie dÃ©sactivÃ©e) |
| L | H | 2% de la frÃ©quence dâ€™origine |
| H | L | 20% |
| H | H | 100% (plein dÃ©bit) |

**Exemple concret**

Imaginons que le capteur veut sortir un signal Ã  **100 kHz** (câ€™est rapide) :

- Si **S0 = H, S1 = H**, tu obtiens 100 kHz â†’ difficile Ã  mesurer avec `pulseIn()`
- Si **S0 = H, S1 = L**, tu obtiens **20% de 100 kHz = 20 kHz** â†’ plus facile pour Arduino
- Si **S0 = L, S1 = H**, tu obtiens seulement **2 kHz**
- Si **S0 = L, S1 = L**, la sortie est **dÃ©sactivÃ©.**

La plus pratique est :

```cpp
digitalWrite(S0, HIGH);
digitalWrite(S1, LOW);
```

â†’ Ã‡a donne **20% de la frÃ©quence dâ€™origine**, un bon compromis entre prÃ©cision et vitesse.

**En rÃ©sumÃ© :**

- **S0 / S1** contrÃ´lent la **vitesse du signal OUT**
- Ce nâ€™est **pas liÃ© Ã  la couleur**, mais Ã  **comment tu veux lire le signal**
- Le but est de **rendre la frÃ©quence mesurable par ton Arduino**, sinon ce serait trop rapide